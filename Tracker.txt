â¦¿ ğ——ğ—®ğ˜ğ—² = ğŸ®ğŸ²-ğ—ğ˜‚ğ—¹ğ˜†-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Palindromic DP ..................

1. Palindromic Substrings.
2. Longest Palindromic Substring.
3. Longest Palindromic Subsequence.
4. Palindrome Partitioning - 1
5. Palindrome Partitioning - 2

â¦¿ ğ——ğ—®ğ˜ğ—² = ğŸ®7-ğ—ğ˜‚ğ—¹ğ˜†-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Palindromic DP ..................

1. Sieve Algo (pow(x,n)).
2. minimum number of characters to be inserted to convert it to a palindrome.

â¦¿ ğ——ğ—®ğ˜ğ—² = ğŸ®8-ğ—ğ˜‚ğ—¹ğ˜†-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Graph ..................

1. BFS of Graph 
2. DFS of Graph
3. Number of Provinces.
4. Detect Cycle in Undirected Graph - (using BFS & DFS).

â¦¿ ğ——ğ—®ğ˜ğ—² = ğŸ®9-ğ—ğ˜‚ğ—¹ğ˜†-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Graph ..................

1. Topological Sort of Graph (DFS).
2. Kahn's Algorithms (Topological Sort - BFS).
3. Detect Cycle in Directed Graph - (using BFS & DFS).

â¦¿ ğ——ğ—®ğ˜ğ—² = 30-ğ—ğ˜‚ğ—¹ğ˜†-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Graph ..................

1. Course Schedule-1
2. Course Schedule-2
3. Is Graph Bipartite?

â¦¿ ğ——ğ—®ğ˜ğ—² = 31-ğ—ğ˜‚ğ—¹ğ˜†-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Graph ..................

1. DSU (Disjoint Set Union).
2. Satisfiability of Equality Equations.

â¦¿ ğ——ğ—®ğ˜ğ—² = 01-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Graph ..................

1. Number of Operations to Make Network Connected.
2. Count Unreachable Pairs of Nodes in an Undirected Graph.
3. Dijkstra's Algorithm | PART-1 (Using Priority Queue).
4. Dijkstra's Algorithm | PART-2 (Using Set).
5. Network Delay Time.

â¦¿ ğ——ğ—®ğ˜ğ—² = 02-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Graph ..................

1. Bellman Ford Algorithms.
2. Floyd Warshall Algorithms.
3. Minimum Spanning Tree.
4. Prim's Algoritms for finding MST.

â¦¿ ğ——ğ—®ğ˜ğ—² = 03-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Graph ..................

1. Kruskal's Algorithm | Minimum Spanning Tree.


â¦¿ ğ——ğ—®ğ˜ğ—² = 04-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© DP ..................

1. Climbing Stairs.
2. Fibonacchi number.


â¦¿ ğ——ğ—®ğ˜ğ—² = 05-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© DP ..................

1. Min Cost Climbing Stairs.
2. Frog Jump
3. House Robber - 1
4. House Robber - 2


â¦¿ ğ——ğ—®ğ˜ğ—² = 06-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© DP ..................

1. Buy and Sell Stock - 1 
2. Buy and Sell Stock - 2
3. Buy and Sell Stock - 3

â¦¿ ğ——ğ—®ğ˜ğ—² = 07-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© DP ..................

1. Buy and Sell Stock - 4 
2. Buy and Sell Stock - with cooldown
3. Buy and Sell Stock - with fee

â¦¿ ğ——ğ—®ğ˜ğ—² = 08-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© DP ..................

1. LCS (longest common subsequence)
2. Printing the LCS

â¦¿ ğ——ğ—®ğ˜ğ—² = 09-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© DP ..................

1. Longest Common Substring .
2. Longest Palindromic Subsequence.
3. Longest Palindromic Substring.


â¦¿ ğ——ğ—®ğ˜ğ—² = 10-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© DP ..................

1. Unique Path - 1
2. MCM (Matrix chain multiplication) - recursion + memoization...
3. Matrix Chain Multiplication  (bottom up)
4. Minimum Cost to Cut a Stick.


â¦¿ ğ——ğ—®ğ˜ğ—² = 11-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© DP ..................

1. Minimum insertions to make string palindrome.
2. Minimum Insertions/Deletions to Convert String 

â¦¿ ğ——ğ—®ğ˜ğ—² = 12-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© DP ..................

1. Shortest Common Supersequence. 
2. LIS (longest increasing subsequence) using 2D dp - Recursion + memoization.
3. LIS (longest increasing subsequence) using 2D dp - tabulation + space optimization.


â¦¿ ğ——ğ—®ğ˜ğ—² = 13-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© DP ..................

1. LIS(longest increasing subseauence) using 1D Dp (tabulation only).
2. Printing Longest Increasing Subsequence using 1D Dp.
3. LIS (longest increasing subsequence) using Binary Search.
4. Number of Longest Increasing Subsequences.


â¦¿ ğ——ğ—®ğ˜ğ—² = 14-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Recursion + DP ..................

1. Combinational Sum - 1
2. Combinational Sum - 2
3. Combinational Sum - 3
4. Combinational Sum - 4

â¦¿ ğ——ğ—®ğ˜ğ—² = 15-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Linked List ..................

1.  Reverse the Linked List.(both iterative & recursive).
2.  Middle of the Linked List.(iterstive & recursive).
3.  Check Palindrome - Linked List (iterstive & recursive).
4.  Detect a loop in LL
5.  Find the starting point in LL.
6.  Length of Loop in LL
7.  Segrregate odd and even nodes in LL.
8.  Remove Nth node from the back of the LL
9.  Delete the middle node of LL
10. Add 1 number given as Linked List.

â¦¿ ğ——ğ—®ğ˜ğ—² = 16-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Linked List ..................

1. Add 2 numbers in LL
2. Merge 2 sorted LL (iterstive & recursive).
3. Sort LL (Merge Sort).
4. Sort a LL of 0's 1's and 2's by changing links
5. Find the intersection point of Y LL
6. Rotate a LL
7. Reverse LL in group of given size K


â¦¿ ğ——ğ—®ğ˜ğ—² = 17-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Linked List ..................

1. Flattening of LL
2. Copy List with Random Pointer.
3. Merge K sorted Linked List
4. Reorder Linked List.
5. Remove Duplicates From Sorted List.
6. Remove Duplicates From UnSorted List
7. Insertion Sort List.

â¦¿ ğ——ğ—®ğ˜ğ—² = 18-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Linked List ..................

1. Remove Linked List Elements.
2. LRU cache.
3. Insert Greatest Common Divisors in Linked List.

â¦¿ ğ——ğ—®ğ˜ğ—² = 19-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Binary Tree ..................

1. InOrder Traversal (using recursion + one stack).
2. PreOrder Traversal (using recursion + one stack).
3. PostOrder Traversal (using recursion + one stack + two stack).
4. InOrder, PreOrder & PostOrder in a single Program.
5. Level order traversal.
6. Array to Binary Tree.


â¦¿ ğ——ğ—®ğ˜ğ—² = 20-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Binary Tree ..................

1. Height of Binary Tree.
2. Check if the Binary tree is height-balanced or not.
3. Diameter of Binary Tree.
4. Maximum path sum.
5. Check if two trees are identical or not.
6. Zig-Zag Traversal of Binary Tree.

â¦¿ ğ——ğ—®ğ˜ğ—² = 21-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Binary Tree ..................

1. Boundary Traversal of Binary Tree.
2. Vertical Order Traversal of Binary Tree.
3. Morris InOrder Traversal of Binary Tree.
4. Morris PreOrder Traversal of Binary Tree.
5. Morris PostOrder Traversal of Binary Tree.

â¦¿ ğ——ğ—®ğ˜ğ—² = 22-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Binary Tree ..................

1. Top View of Binary Tree.
2. Bottom View of Binary Tree.
3. Left Side View of Binary Tree.
4. Right Side View of Binary Tree.
5. Symmetric Binary Tree.


ğ——ğ—®ğ˜ğ—² = 23-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Binary Tree ..................

1. LCA in Binary Tree.
2. Check Completeness of a Binary Tree.
3. Count total Nodes in a COMPLETE Binary Tree.
4. Check for Children Sum Property.
5. Path Sum (root to target).

ğ——ğ—®ğ˜ğ—² = 24-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Binary Tree ..................

1. Construct Binary Tree from inorder and preorder.
2. Construct the Binary Tree from Postorder and Inorder Traversal.
3. Serialize and deserialize Binary Tree.
4. Invert Binary Tree.
5. All Root to Leaf Paths In Binary Tree.

ğ——ğ—®ğ˜ğ—² = 25-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Binary Tree ..................

1. Maximum Width of a Binary Tree.
2. Flatten Binary Tree to Linked List.
3. Minimum time taken to BURN the Binary Tree from a Node.
4. Print all the Nodes at a distance of K in a Binary Tree.

ğ——ğ—®ğ˜ğ—² = 26-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Binary Search Tree ..................

1. Convert Sorted Array to Binary Search Tree.
2. Search in a Binary Search Tree.
3. Find Min/Max in BST.
4. Ceil in a Binary Search Tree.
5. LCA in Binary Search Tree.

ğ——ğ—®ğ˜ğ—² = 27-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Binary Search Tree ..................

1. Floor in a Binary Search Tree.
2. Insert into a Binary Search Tree.
3. Find K-th smallest element in BST.
4. Find K-th largest element in BST.
5. Check if a tree is a BST or BT or (Validate BST).

ğ——ğ—®ğ˜ğ—² = 28-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Binary Search Tree ..................

1. Construct a BST from a preorder traversal.
2. Inorder  Predecessor in BST.
3. Inorder Successor in BST. 
4. Merge 2 Binary Tree (very Easy).
5. Convert Binary Tree to BST without changing Structure of BT.
6. Merge 2 BST.
7. Two Sum In BST | Check if there exists a pair with Sum K.
8. Delete a Node in Binary Search Tree.
9. Recover BST | Correct BST with two nodes swapped.
10.Largest BST in Binary Tree.


ğ——ğ—®ğ˜ğ—² = 29-August-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Stack & Queues ..................

1. Implement Stack using Arrays.
2. Implement stack using linked list.
3. Implement stack using Single Queue.
4. Implement stack using 2 Queues.

5. Infix to Postfix Conversion using Stack.
6. Convert Infix To Prefix Notation.

7. Postfix to Infix.
8. Prefix to Infix Conversion.

9. Postfix to Prefix Conversion.
10.Prefix to Postfix Conversion.

ğ——ğ—®ğ˜ğ—² = 30-August-ğŸ®ğŸ¬ğŸ®ğŸ°


ğŸš© Stack & Queues ..................

1. Check for balanced paranthesis.
2. Evaluate Reverse Polish Notation.
3. Implement Min Stack.
4. Next Greater Element.
5. Next Greater Element 2 (circular).


ğ——ğ—®ğ˜ğ—² = 31-August-ğŸ®ğŸ¬ğŸ®ğŸ°


ğŸš© Stack & Queues ..................

1. Next Smaller Element.
2. Trapping Rainwater.
3. Asteroid Collision.
4. Sum of Subarray Minimums.
5. Sum of Subarray Ranges.(Extended version of Above Problem).

ğ——ğ—®ğ˜ğ—² = 1-September-ğŸ®ğŸ¬ğŸ®ğŸ°


ğŸš© Stack & Queues ..................

1. Remove-k-digits From String to form minimum Number.
2. Largest Rectangle in Histogram.
3. 132 Pattern (prev grater element).


ğ——ğ—®ğ˜ğ—² = 2-September-ğŸ®ğŸ¬ğŸ®ğŸ°


ğŸš© Arrays ..................

1.  Largest/Smallest Element in an Array.
2.  Second Largest/Smallest Element in an Array without sorting.
3.  Check if the array is sorted.
4.  Remove duplicates from Sorted array.
5.  Left Rotate an array by one place.
6.  Right rotate an array by one places.
7.  Left Rotate an array by D place.
8.  Right Rotate an array by D place.
9.  Move Zeros to end.
10. Find the Union.

11. Find the Intersection.
12. Find missing number in an array.
13. Maximum Consecutive Ones.
14. Find the number that appears once, and other numbers twice.
15. Longest subarray with given sum K(positives).
16. Longest subarray with sum K (Positives + Negatives).


ğ——ğ—®ğ˜ğ—² = 3-September-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Arrays ..................

1.  2 - Sum.
2.  Sort an array of 0's 1's and 2's.
3.  Majority Element (>n/2 times) (Moore Voting Algorithm).
4.  Kadane's Algorithm, maximum subarray sum.
5.  Print subarray with maximum subarray sum (extended version of above problem).
6.  Rearrange the array in alternating positive and negative items.

ğ——ğ—®ğ˜ğ—² = 4-September-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Arrays ..................

1.  Generate All Permutations.
2.  Next Permutation.
3.  Leaders in an Array problem.

ğ——ğ—®ğ˜ğ—² = 5-September-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Arrays ..................

1. Longest Consecutive Sequence in an Array.
2. Set Matrix Zeros.
3. Rotate Matrix by 90 degrees clockwise.
4. Rotate matrix by 90 degree anticlockwise.
5. Rotate matrix by 180 degree.


ğ——ğ—®ğ˜ğ—² = 6-September-ğŸ®ğŸ¬ğŸ®ğŸ°  to ğ——ğ—®ğ˜ğ—² = 10-September-ğŸ®ğŸ¬ğŸ®ğŸ°

(ã£â—”â—¡â—”)ã£ â™¥ Something Went Wrong ! â™¥


ğ——ğ—®ğ˜ğ—² = 11-September-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Arrays ..................

1. Print the matrix in spiral manner (i)
2. 2-Sum
3. 3-Sum
4. 4-Sum
5. Majority Element (n/3 times).(Extended version of Moore Voting Algorithm)


ğ——ğ—®ğ˜ğ—² = 12-September-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Arrays ..................

1. Largest Subarray with 0 Sum.
2. Count number of subarrays with given xor K.
3. Merge two sorted arrays without extra space.
4. Maximum Product Subarray.
5. Find the repeating and missing number.


ğ——ğ—®ğ˜ğ—² = 13-September-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Arrays ..................

1. Pascal's Triangle.
2. Merge Overlapping Subintervals.
3. Count Inversions.
4. Reverse Pairs.


â¦¿ ğ——ğ—®ğ˜ğ—² = 14-September-ğŸ®ğŸ¬ğŸ®ğŸ°

ğŸš© Graph ..................

1. Number of Islands
2. 

